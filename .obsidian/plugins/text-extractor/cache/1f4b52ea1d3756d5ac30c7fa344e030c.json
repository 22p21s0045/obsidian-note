{"path":"Lecture Kmutt/INT206/material/INT206_05_TransactionManagement_Part1_02_2023.pdf","text":"TRANSACTION MANAGEMENT Part I Sanit Sirisawatvatana and Sunisa Sathapornvajana Chapter Objectives • Function and importance of transactions. • Properties of transactions. • Concurrency Control • Locking • Deadlock • Timestamping • Database Recovery • Transaction log • Checkpointing 2 Review • Types of SQL statements • DML: Data Manipulation Language • SELECT, INSERT, UPDATE, DELETE statements, etc. • DDL: Data Definition Language • CREATE, ALTER, DROP, TRUNCATE statements, etc. • DCL: Data Control Language • GRANT and REVOKE statements • TCL: Transaction Control Language • COMMIT, ROLLBACK and SAVEPOINT statements 3 Transaction • Definition: • Action, or series of actions, carried out by user or application, which reads or updates contents of database. • Transaction • Is a logical unit of work on the database • May be an entire (or a part of) program or a single statement that involve any number of operations on the database • Transforms database from one consistent state to another • Database operations • Read/Write 4 Example: Transaction 5 State Transition Diagram for a Transaction 6 States of a Transaction • ACTIVE • Executes database and non-database operations • COMMITED • ABORTED • PARTIALL COMMITED • Occurs after the final statement has been executed • It may be found that transaction has violated an integrity constraint • FAILED • Occurs when transaction cannot be committed or transaction is aborted • The user might abort the transaction • The concurrency control protocol might abort the transaction to ensure serializability 7 Outcomes of a Transaction Two outcomes: • COMMITED • Transaction completes successfully • The database reaches a new consistent state • ABORTED • Transaction does not execute successfully • The database must be restored to the consistent state (previous consistent state) before it started (Rolled back or undone) • A committed transaction cannot be aborted. • An aborted transaction that is rolled back can be restarted later and may execute successfully and commit in later time. 8 Properties of Transactions (ACID) All transactions should have basic four properties: • Atomicity • An Indivisible unit • All or Nothing • Consistency • Database transforms from one consistent state to another consistent state (consistent before and after transaction) • Isolation • Executes independently of one another (not interfere with each other). • Durability • The completed transaction is permanently recorded in database. • The completed transaction must not be lost from failure. 9 Example: Transaction A banking application is the classic example of why transactions are necessary. Imagine a bank’s database with two tables: checking and savings. To move $200 from Jane’s checking account to her savings account, you need to perform at least three steps: 1. Make sure her checking account balance is greater than $200. 2. Subtract $200 from her checking account balance. 3. Add $200 to her savings account balance. The entire operation should be wrapped in a transaction so that if any one of the steps fails, any completed steps can be rolled back.You start a transaction with the START TRANSACTION statement and then either make its changes permanent with COMMIT or discard the changes with ROLLBACK. So, the SQL for our sample transaction might look like this: 1 START TRANSACTION; 2 SELECT balance FROM checking WHERE customer_id = 10233276; 3 UPDATE checking SET balance = balance - 200.00 WHERE customer_id = 10233276; 4 UPDATE savings SET balance = balance + 200.00 WHERE customer_id = 10233276; 5 COMMIT; 10 ACID Transaction https://www.openxcell.com/blog/cockroachdb-more-than-just-an-invincible-database/ 11 DBMS Transaction Subsystem 12 DBMS Transaction Subsystem • Concurrency Control • To maximize concurrency without allowing concurrently executing transactions to interfere with each other • Database Recovery • To ensure that database is consistent when a failure occurs during the transaction 13 Concurrency Control • Definition: • Process of managing simultaneous operations on the database without having them interfere with one another. • when two or more users are accessing database simultaneously • All users are only reading • => No way to interfere one another • At least one is updating data • => May be interfere one another • => Can result in inconsistencies 14 Problems in Concurrency Potential problems caused by concurrency: • Lost update problem • Uncommitted dependency (dirty read) • Inconsistent analysis problem 15 The Lost Update Problem • At t4 T2 Loss the updated bal x 200 • This can avoid by preventing T1 from reading bal x until after update. • Successfully completed update is overridden by another user. 16 Uncommitted Dependency Problem • Occurs when one transaction can see intermediate results of another transaction before it has committed. • T4 updates bal x to £200 but it aborts • T3 has read new value of bal x (£200) giving a new balance of £190, instead of £90. • This problem can be avoided by preventing T3 from reading bal x until after T4 commits or aborts. 17 Inconsistent Analysis Problem • Occurs when transaction reads several values but second transaction updates some of them during execution of first. • The problem can be avoided by preventing T6 from reading bal x and bal z until after T5 completed updates. 18 Inconsistent Retrieval Problems • Interference causes inconsistency among multiple retrievals of a subset of data • Incorrect summary (Inconsistent analysis problem) • Non-repeatable (or fuzzy) read • Phantom read 19 Serializability and Recoverability • When multiple transactions run concurrently, there is a possible that the database may be left in an inconsistent state. • Serializability is a concept that helps to identify which non- serial schedules are correct and will maintain the consistency of the database. • Schedule • A sequence of the operations by a set of concurrent transactions that prevents the order of the operations in each of the individual transactions. 20 Serial Schedule vs. Non-serial Schedule • Serial schedule • Is always a serializable schedule. • A schedule where operations of each transaction are executed consecutive without any interleaved operations from other transactions. • A transaction only starts when the other transaction finished executed. • Non-serial schedule • A schedule where the operations from a set of current transactions are interleaved. • Is said to be serializable schedule, if it is equivalent to the serial schedule of those n transactions. 21 Serializability • The objective of serializability • Is to find non-serial schedules that allow transactions to execute concurrently without interfering with one another, and thereby produce a database state that could be produced by a serial execution. • In serializability, the ordering of read/writes is important: • If two transactions only read a data item, they do not conflict and order is not important. • If two transactions either read or write completely separate data items, they do not conflict and order is not important. • If one transaction writes a data item and another reads or writes same data item, order of execution is important. 22 Recoverability • Serializability identifies schedules that maintain the consistency of database (none of the transactions in the schedule fails) • Recoverability of transactions within a schedule: • If a transaction fails, the atomicity property requires that we undo the effects of transactions. • The durability property states that one a transaction commits, its changes cannot be undone (without running another, compensating, transaction). 23 Unrecoverable Schedule • G is unrecoverable schedule, because T2 read the value of A written by T1, and committed. • T1 later aborted, therefore the value read by T2 is wrong, but since T2 committed. 24 Recoverable Schedule • A schedule where, for each pair of transactions T i and T j , if T j reads a data item previously written by T i , then the commit operation of T i precedes the commit operation of T j. • F is recoverable because T1 commits before T2, that makes the value read by T2 corrects, Then T2 can commit itself. • In F2, if T1 aborted, T2 has to abort because the value of A it read is incorrect 25 Concurrency Control Techniques • Two concurrency control techniques • Locking • Timestamping • Both are conservative (or pessimistic) approaches • They cause transaction to be delayed when they conflict with other transactions • Optimistic approaches based on: • Transaction conflict is rare. So they allow transactions to run unsynchronized and check for conflicts only when the transaction commits at the end 26 Locking Methods • Definition: • A procedure used to control concurrency access to data. Transaction uses locks to deny access to other transactions to prevent incorrect results. • Locking methods are the most widely used approach to ensure serializability of concurrent transactions. • Transaction must request a lock on a data item before it read or write the data item. • The lock prevents another transaction from modifying or reading the item. • The other transaction must wait until the lock is released. 27 Types of a lock • Two types: • Shared lock (read lock) • Is used for read-only mode (reading purpose) • Transaction requests shared lock on a data item in order to read its content. • Updating the data is not allowed • Exclusive lock (write lock) • Is used for write mode • Only the transaction that requests a lock can read and update the data item • The other transactions can not read , write or lock the data and must wait until the lock is released 28 Flowchart of locking 29 Lock Matrix T1 issue a lock at t = 0 T2 issue a lock at t = 10 Shared Exclusive Shared Both are granted shared locks Both only Read Only T1 is granted an exclusive lock T2 wait for a lock T1 Read/Write Exclusive Only T1 is granted a shared lock T2 wait for a lock T1 only Read Only T1 is granted an exclusive lock T2 wait for a lock T1 Read/Write Some systems allow transaction to upgrade shared (read) lock to an exclusive lock, or downgrade exclusive lock to a shared lock. 30 Locking Granularity Database Table Page Record Column 31","libVersion":"0.3.1","langs":""}