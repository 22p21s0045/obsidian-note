{"path":"Lecture Kmutt/INT203/material/Chapter7-FetchAPI.pdf","text":"Chapter 7 - Fetch API Asst.Prof. Dr. Umaporn Supasitthimethee ผศ.ดร.อุมาพร สุภสิทธิเมธี https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API 2Asst.Prof.Dr. Umaporn Supasitthimethee Synchronous/Asynchronous 3Asst.Prof.Dr. Umaporn Supasitthimethee Asynchronous vs. Synchronous • Synchronous tasks are performed one at a time and only when one is completed, the following is unblocked. In other words, you need to wait for a task to finish to move to the next one. https://developer.mozilla.org/en-US/docs/Glossary/Asynchronous • Asynchronous software design expands upon the concept by building code that allows a program to ask that a task be performed alongside the original task (or tasks), without stopping to wait for the task to complete. When the secondary task is completed, the original task is notified using an agreed-upon mechanism so that it knows the work is done, and that the result, if any, is available. console.log(`hello `) console.log('world, ') console.log('bye’) console.log(`hello `) setTimeout(() => console.log('world, '), 3000) console.log('bye’) hello Bye world hello World Bye 4Asst.Prof.Dr. Umaporn Supasitthimethee Asynchronous Functions In JavaScript, a callback function is a function that is passed into another function as an argument. This function can then be invoked during the execution of that higher order function. Since, in JavaScript, functions are objects, functions can be passed as arguments. console.log('Hello’) //setTimeout is an //asynchronous function setTimeout(function () { console.log('JS') }, 5000) console.log('Bye bye') //Console Hello Bye bye //until 5 seconds JS setTimeout() executes a particular block of code once after a specified time has elapsed. setTimeout() is an asynchronous function, meaning that the timer function will not pause execution of other functions in the functions stack. 5Asst.Prof.Dr. Umaporn Supasitthimethee Promise 6Asst.Prof.Dr. Umaporn Supasitthimethee Promises • Promises are asynchronous. • “I promise to do this whenever that is true. If it isn't true, then I won’t.” • With Promises, we can defer execution of a code block until an async request is completed. This way, other operations can keep running without interruption. • Promises have three states: • pending: initial state, neither fulfilled nor rejected. • fulfilled: meaning that the operation was completed successfully. • rejected: meaning that the operation failed. pending fulfilled rejected New promise Resolved promise Rejected promise 7Asst.Prof.Dr. Umaporn Supasitthimethee Creating a Promise • The Promise object represents the eventual completion (or failure) of an asynchronous operation and its resulting value. • The Promise object is created using the new keyword and contains the promise; • This is an executor function which has a resolve and a reject callback const promise = new Promise(function(resolve, reject) { // promise description }) 8Asst.Prof.Dr. Umaporn Supasitthimethee Using Promises .then() .then()receives a function with an argument which is the resolve value of our promise. .catch()returns the reject value of our promise async function doSomething(done) { return new Promise((resolve, reject) => { console.log('waiting...') setTimeout(() => { done ? resolve('success') : reject('failure') }, 5000) }) } async function thenDoSomething(result) { doSomething(result) .then((x) => { console.log(x + ', your activity is success') }) .catch((error) => { console.log(`${error}, your activity fails`) }) } thenDoSomething(false) waiting... failure, your activity fails 9Asst.Prof.Dr. Umaporn Supasitthimethee Using Promises async/await • async function returns a promise -- if the function returns a value, the promise will be resolved with the value, but if the async function throws an error, the promise is rejected with that value. • await keyword is only used in an async function to ensure that all promises returned in the async function are synchronized • await eliminates the use of callbacks in .then() and .catch() async function waitingSomething(result) { try { const x = await doSomething(result) console.log(x + ', your activity is success') } catch (e) { console.log(`${error}, your activity fails`) } } waitingSomething(true) waiting... success, your activity is success async function doSomething(done) { return new Promise((resolve, reject) => { console.log('waiting...') setTimeout(() => { done ? resolve('success') : reject('failure') }, 5000) }) } 10Asst.Prof.Dr. Umaporn Supasitthimethee REST API 11Asst.Prof.Dr. Umaporn Supasitthimethee REST APIs • Representational State Transfer (REST) APIs communicate via HTTP requests to perform standard functions like creating, reading, updating, and deleting records (also known as CRUD) within a resource. • Request headers and parameters are also important in REST API calls because they include important information such as metadata, authorizations, uniform resource identifiers (URIs), cookies and more. • The representation of a respond resource most often be JSON, HTML or XML. JSON is popular because it’s readable by both humans and machines. 12Asst.Prof.Dr. Umaporn Supasitthimethee JSON structure • JSON is a string whose format very much resembles JavaScript object literal format. • JSON requires double quotes to be used around strings and property names. Single quotes are not valid other than surrounding the entire JSON string. • You can include the same basic data types inside JSON as you can in a standard JavaScript object — strings, numbers, arrays, booleans, and other object literals. • JSON is purely a string with a specified data format — it contains only properties, no methods. • We can also convert arrays to/from JSON. https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/JSON 13Asst.Prof.Dr. Umaporn Supasitthimethee Three elements in REST API • Request—This is the data you send to the API across HTTP Protocol • Response—Any data you get back from the server after a successful / failed request. • Headers—Additional metadata passed to the API to help the server understand what type of request it is dealing with, for example “content-type” 14Asst.Prof.Dr. Umaporn Supasitthimethee Using HTTP Methods for RESTful Services https://www.restapitutorial.com/lessons/httpmethods.html 15Asst.Prof.Dr. Umaporn Supasitthimethee • The Fetch API provides a JavaScript interface for accessing and manipulating parts of the HTTP pipeline, such as requests and responses. • It also provides a global fetch() method that provides an easy, logical way to fetch resources asynchronously across the network. Using Fetch API 16Asst.Prof.Dr. Umaporn Supasitthimethee fetch() fetch(resource [, init]) resource This defines the resource that you wish to fetch including a URL object — that provides the URL of the resource you want to fetch. init Optional An object containing any custom settings that you want to apply to the request. The possible options are: • method: The request method, e.g., GET, POST. • headers: Any headers you want to add to your request, contained within a Headers object or an object literal with String values. • body: Any body that you want to add to your request. Note that a request using the GET method cannot have a body. 17Asst.Prof.Dr. Umaporn Supasitthimethee Using Fetch API • The fetch() method takes one mandatory argument, the path to the resource you want to fetch. • It returns a promise that resolves to the response to that request — as soon as the server responds with headers — even if the server response is an HTTP error status. function fetch(url) { return new Promise(function (resolve, reject) { // promise description } ) } fetch('http://example.com/movies.json') .then(response => response.json()) .then(data => console.log(data)); https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch 18Asst.Prof.Dr. Umaporn Supasitthimethee json() • The json() method of the Response interface takes a response stream and reads it to completion. It returns a promise which resolves with the result of parsing the body text as JSON. • Note that despite the method being named json(), the result is not JSON but is instead the result of taking JSON as input and parsing it to produce a JavaScript object. async function fetchData(endpoint) { try { const res = await fetch(endpoint); const data = await res.json(); return data; } catch (error) { throw new Error(res.status); } } 19Asst.Prof.Dr. Umaporn Supasitthimethee JSON-Server 20Asst.Prof.Dr. Umaporn Supasitthimethee https://www.npmjs.com/package/json-server/v/1.0.0-alpha.23 21Asst.Prof.Dr. Umaporn Supasitthimethee JSON-Server Steps 1. Install JSON Server npm install json-server หมายเหตุ ถ้าเพิ่ม –g (หมายถึง global ใช้ได้ทุก project ) 2. Create a \" ./data/db.json \" file with some data 3. Create script for running json-server backend {\"posts\": [ { \"id\": \"1\", \"title\": \"a title\", \"views\": 100 }, { \"id\": \"2\", \"title\": \"another title\", \"views\": 200 } ] } \"scripts\": { \"backend\": \"json-server --watch ./data/db.json --port 5000\" } 22Asst.Prof.Dr. Umaporn Supasitthimethee \"scripts\": { \"dev\": \"vite\", \"build\": \"vite build\", \"preview\": \"vite preview\", \"backend\": \"json-server --watch ./data/db.json --port 5000\" }, \"dependencies\": { \"json-server\": \"^0.17.2\", \"vue\": \"^3.2.47\" }, npm run backend package.json Create script to run JSON-Server (package.json) 23Asst.Prof.Dr. Umaporn Supasitthimethee JSON-Server Resources and EndPoints Resources http://localhost:5000/posts http://localhost:5000/comments { \"posts\": [ { \"id\": \"1\", \"title\": \"a title\", \"views\": 100 }, { \"id\": \"2\", \"title\": \"another title\", \"views\": 200 } ], \"comments\": [ { \"id\": \"1\", \"text\": \"a comment about post 1\", \"postId\": \"1\" }, { \"id\": \"2\", \"text\": \"another comment about post 1\", \"postId\": \"1\" } ] } 24Asst.Prof.Dr. Umaporn Supasitthimethee JSON-Server Endpoints http://localhost:5000/posts [ { \"id\": \"1\", \"title\": \"a title\", \"views\": 100 }, { \"id\": \"2\", \"title\": \"another title\", \"views\": 200 } ] { \"id\": \"1\", \"title\": \"a title\", \"views\": 100 } http://localhost:5000/posts/1 25Asst.Prof.Dr. Umaporn Supasitthimethee Env Variables and Modes 26Asst.Prof.Dr. Umaporn Supasitthimethee Env Variables and Modes (put .env file at root project) • Env variables start with “yourVariableName” • .env file for loaded in all cases • .env.[mode] only loaded in specified mode https://vitejs.dev/guide/env-and-mode.html #.env.production VITE_BASE_URL=http://example.com DB_PASSWORD=foo //.env.production (only on build production) #.env VITE_BASE_URL=http://localhost:5000 DB_PASSWORD=foo //.env 27Asst.Prof.Dr. Umaporn Supasitthimethee Env Variables and Modes • To prevent accidentally leaking env variables to the client, only variables prefixed with VITE_ are exposed to your Vite-processed code. e.g. for the following env variables: console.log(import.meta.env.VITE_SOME_KEY) // 123 console.log(import.meta.env.DB_PASSWORD) // undefined VITE_SOME_KEY=123 DB_PASSWORD=foobar https://vitejs.dev/guide/env-and-mode.html#env-files //.env Your source file Only VITE_SOME_KEY will be exposed as import.meta.env.VITE_SOME_KEY to your client source code, but DB_PASSWORD will not. 28Asst.Prof.Dr. Umaporn Supasitthimethee Fetch API CRUD [ { \"id\": \"1\", \"category\": \"home\", \"description\": \"Buy groceries\" }, { \"id\": \"2\", \"category\": \"work\", \"description\": \"Finish project report\" }, { \"id\": \"3\", \"category\": \"home\", \"description\": \"Clean the house\" }, Prepare your JSON https://www.npmjs.com/package/json-server/v/1.0.0-alpha.23 29 async-await promise.then() GET method Fetch contains HTTP response, not the actual JSON. This includes headers, status code, etc. To extract the JSON body content from the response, we use the json() method. async function getTodos() { try { const res = await fetch('https://localhost:5000/todos') const data = await res.json() console.log(data) } catch (error) { console.error('Error:', error) } } fetch('https://localhost:5000/todos') .then(res => response.json()) .then(data => console.log(data)) .catch((error) => console.error('Error:', error)) 30 async function createTodo() { try { const res = await fetch('https:// localhost:5000/todos', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ category: 'Home', description: 'Buy milk', }), }) const addedTodo = await res.json() //frontend data handle here } catch (error) { console.error('Error:', error) } } fetch('https://localhost:5000/todos', { method: 'POST', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ category: 'Home', description: 'Buy milk', }), }) .then(res => res.json()) .then(addedTodo => //frontend data handle here) .catch((error) => console.error('Error:', error)) async-await promise.then() POST (Add) method *The fetch first parameter should always be the URL, a second JSON object with options like method, headers, request body, and so on. **The JSON.stringify() method converts a JavaScript object or value to a JSON string. console.log(JSON.stringify({ x: 5, y: 6 })); // expected output: \"{\"x\":5,\"y\":6} 31 async-await DELETE method promise.then() fetch('https://localhost:5000/todos/1', { method: 'DELETE', }) .then((res) => { if(res.status === 200) console.log('Deleted’) //frontend data handle here) }) .catch((error) => console.error('Error:', error)) async function deleteTodo() { try { const res = await fetch('https://localhost:5000/todos/1', { method: 'DELETE', }) if(res.status === 200){ console.log('Deleted’) //frontend data handle here } } catch (error) { console.error('Error:', error) } } 32 PUT (Update with Replace) method async function updateTodo() { try { const res = await fetch('https://localhost:5000/todos/1', { method: 'PUT', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ category: 'Work', description: 'Prepare meeting notes', }), }) const editedTodo = await res.json() //frontend data handle here } catch (error) { console.error('Error:', error) } } Async-Await replaces an existing entire to-do item or creates new if it does not exist. 33 PUT (Update with Replace) method fetch('https://localhost:5000/todos/1', { method: 'PUT', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ category: 'Work', description: 'Prepare meeting notes', }), }) .then(res => { const editedTodo = res.json() //frontend data handle here }) .catch((error) => console.error('Error:', error)) promise.then() 34 PATCH (Update with Modify) method async function patchTodo() { try { const res = await fetch('https://localhost:5000/todos/1', { method: 'PATCH', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ description: 'Prepare meeting notes and presentation', }), }) const editedTodo = await res.json() //frontend data handle here } catch (error) { console.error('Error:', error) } } Async-Await partially updates an existing to-do item without modifying the other field. 35 PATCH (Update with Modify) method fetch('https://localhost:5000/todos/1', { method: 'PATCH', headers: { 'Content-Type': 'application/json', }, body: JSON.stringify({ description: 'Prepare meeting notes and presentation', }), }) .then(res => { const editedTodo = res.json() //frontend data handle here }) .catch((error) => console.error('Error:', error)) promise.then() 3637Asst.Prof.Dr. Umaporn Supasitthimethee Fetch API Demo TodoList Project 38Asst.Prof.Dr. Umaporn Supasitthimethee TodoList (Add/Edit/Delete/List) App.vue TodoManager.vue (onMounted call endpoint to get todos) ListModal.vue (['items']) TodoList.vue (['todos']) (['deleteTodo', 'editMode']) AddEditTodo.vue (['todo']) (['saveNewTodo', 'closeModal']) libs -TodoManagement.js -fetchUtils.js BaseCard.vue (['size', 'variant']) TodoList item .env VITE_BASE_URL 39","libVersion":"0.3.1","langs":""}